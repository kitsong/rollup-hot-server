{"code":"import { __awaiter } from \"tslib\";\r\nimport { resolve } from 'path';\r\nimport mime from 'mime';\r\nimport httpProxy from 'http-proxy';\r\nexport class ServerConfig {\r\n    constructor(config) {\r\n        this.host = config.host || 'localhost';\r\n        this.port = config.port || 8000;\r\n        this.https = config.https || null;\r\n        this.open = config.open || true;\r\n        this.openPath = config.openPath || '';\r\n        this.watch = config.watch || true;\r\n        this.proxy = config.proxy || {};\r\n    }\r\n}\r\nexport class Server {\r\n    constructor(cf) {\r\n        this.config = cf;\r\n        const { proxy, https } = this.config;\r\n        this.proxies = new Map();\r\n        this.createdProxyServer(proxy, this.proxies);\r\n        this.close();\r\n        this.server = this.createServer(https);\r\n    }\r\n    listen() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return new Promise((resolve, reject) => {\r\n                try {\r\n                    const { port } = this.config;\r\n                    const server = this.server.listen(port, () => {\r\n                        resolve({\r\n                            // for test teardown\r\n                            close() {\r\n                                return __awaiter(this, void 0, void 0, function* () {\r\n                                    yield new Promise(resolve => {\r\n                                        server.close(resolve);\r\n                                    });\r\n                                });\r\n                            },\r\n                        });\r\n                    });\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    close() {\r\n        if (this.server) {\r\n            this.server.close();\r\n        }\r\n        else {\r\n            this.closeServerOnTermination();\r\n        }\r\n    }\r\n    closeServerOnTermination() {\r\n        const terminationSignals = ['SIGINT', 'SIGTERM', 'SIGQUIT', 'SIGHUP'];\r\n        terminationSignals.forEach(signal => {\r\n            process.on(signal, () => {\r\n                if (this.server) {\r\n                    this.server.close();\r\n                    process.exit();\r\n                }\r\n            });\r\n        });\r\n    }\r\n    createdProxyServer(proxy, proxies) {\r\n        Object.keys(proxy).forEach((key) => {\r\n            const option = proxy[key];\r\n            const proxyServer = httpProxy.createProxyServer(option);\r\n            proxyServer.on('error', err => {\r\n                console.error(`http proxy error:\\n${err.stack}`);\r\n            });\r\n            proxies.set(key, {\r\n                proxy: proxyServer,\r\n                option: option,\r\n            });\r\n        });\r\n    }\r\n    createServer(https) {\r\n        return https\r\n            ? require('https').createServer(https, this.requestListener.bind(this))\r\n            : require('http').createServer(this.requestListener.bind(this));\r\n    }\r\n    requestListener(req, res) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { path } = req;\r\n            console.log(path);\r\n            // for (const [context, data] of this.proxies) {\r\n            //   if (this.doesProxyContextMatchUrl(context, url)) {\r\n            //     const { proxy, option } = data\r\n            //     proxy.web(req as any, res, option)\r\n            //     return\r\n            //   }\r\n            // }\r\n        });\r\n    }\r\n    doesProxyContextMatchUrl(context, url) {\r\n        return (context.startsWith('^') && new RegExp(context).test(url)) || url.startsWith(context);\r\n    }\r\n    notFound(response, filePath) {\r\n        response.writeHead(404);\r\n        response.end('404 Not Found' + '\\n\\n' + filePath + '\\n\\n(rollup-plugin-serve)', 'utf-8');\r\n    }\r\n    findFile(url) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let filePath = resolve('.', url);\r\n            if (filePath.endsWith('/')) {\r\n                filePath = resolve(filePath, 'index.html');\r\n            }\r\n            console.log(filePath);\r\n            // try {\r\n            //   await fs.readFile(filePath)\r\n            // }\r\n        });\r\n    }\r\n    found(response, filePath, content) {\r\n        const mineType = mime.getType(filePath);\r\n        response.setHeader('Content-Type', mineType);\r\n        response.writeHead(200);\r\n        response.end(content, 'utf-8');\r\n        // response.writeHead(200, { 'Content-Type': mime.getType(filePath) })\r\n        // ps: node types writeHead headers types(OutgoingHttpHeaders) is wrong, go to change\r\n    }\r\n}\r\n","references":["/Users/songwenjie/Desktop/rollup-hot-server/node_modules/@types/mime/index.d.ts","/Users/songwenjie/Desktop/rollup-hot-server/node_modules/@types/http-proxy/index.d.ts"]}
